
% ---------------------------------------------
% Autor:        UOS, Arbeitsgruppe Software Engineering und CAU Kiel
%               mit Verbesserungen von Valentin Bruder (26.06.13)
% Beschreibung: Vorlage für Seminarausarbeitung
% Dateiname:    ausarbeitung.tex 
% Projekt:      Seminare
% erstellt am:  24.04.2013
% geändert am:  $Date$
% ---------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%             Achtung!!                %%%
%%% In diesem Beispiel werden Pakete ver-%%%
%%% wendet, die ggf. nachinstalliert wer-%%%
%%% den müssen!                          %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Es wird KOMA-Script verwendet        %%%
%%% welches in den meisten TeX-          %%%
%%% Distributionen enthalten ist!        %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\documentclass[a4paper, 11pt, DIV=11, listof=numbered, bibliography=numbered, pointlessnumbers]{scrartcl}
\documentclass[a4paper, 11pt, DIV=11, listof=numbered, numbers=noenddot]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%     benötigte Pakete                   %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[backend=biber,style=alphabetic,sortlocale=de]{biblatex}
\usepackage[utf8]{inputenc}     % Paket für Eingabekodierung (utf8 für die meisten aktuellen Linux-Distributionen): Umlaute
%\usepackage[latin1]{inputenc}  % Eingabekodierung für Windows falls UTF8 nicht unterstützt wird
\usepackage[ngerman]{babel}		% Deutsche Spracheigenheiten
\usepackage[autostyle=true,german=quotes]{csquotes}
\usepackage{amsmath}		% AMS Mathe und Symbolpakete für mehr Möglichkeiten
\usepackage{amsfonts}
%%\usepackage{amssymb}
% \usepackage{floatflt}
% \usepackage{float}
\usepackage{graphicx}		% Grafiken einbinden
\usepackage{xcolor}
\usepackage{hyperref}		% Erzeugt Verlinkungen im Dokument
\usepackage{url}			% erlaubt das einfache Schreiben von URLs
\usepackage{listings}		% für Listings (ftp://ftp.ctan.org/tex-archive/macros/latex/contrib/listings/listings.pdf)
\usepackage[T1]{fontenc} 	% Wichtig für Umlaute in PDFs
\usepackage{lmodern}		% Für bessere Schriftdarstellung trotz fontenc


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%      Weitere sinnvolle Pakete          %%%
%%%      ggf. Kommentar entfernen          %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{multirow}		% Zeilen in Tabellen zusammenfassen (http://tug.ctan.org/tex-archive/macros/latex/required/graphics/grfguide.pdf)
\usepackage{hhline}		% Horizontale Linien in Tabellen feiner gestalten

% Unterabbildungen können mit dem subfig-Paket realisiert werden.
% (z.B. Abb. 1a) (http://tug.ctan.org/tex-archive/macros/latex/contrib/subfig/subfig.pdf)
\usepackage{subfig}

\usepackage{blindtext}

\usepackage{hyperref}


% Sehr gute Möglichkeiten um Grafiken direkt in LaTeX zu erzeugen bietet Tikz (http://mirror.ctan.org/graphics/pgf/base/doc/generic/pgf/pgfmanual.pdf und http://www.statistiker-wg.de/pgf/tutorials.htm)
%\usepackage{tikz}		% 
%\usetikzlibrary[shapes.misc,shapes.geometric,arrows,decorations.pathmorphing,backgrounds,fit,positioning]

%Globale Einstellungen für das Listingspaket
\lstset{numbers=left,
	basicstyle=\ttfamily\small, 		% Setzt den Standardstil
	keywordstyle=\bfseries\small, 		% Setzt den Stil für Schlüsselwörter
	identifierstyle=\bfseries, 		% Identifier fett
	tabsize=2,				% Breite der Tabs
	showstringspaces=false,			% Leerzeichen in Strings nicht anzeigen
	commentstyle=\color{red!40}, 		% Stil für Kommentare
	stringstyle=\color{blue}, 		% Stil für Strings (gekennzeichnet mit "String")
	breaklines=true, 			% Zeilen werden umgebrochen
	numbers=left, 				% Zeilennummern links
	numberstyle=\tiny, 			% Stil für die Seitennummern
	frame=single, 				% Rahmen	
	backgroundcolor=\color{black!10}, 	% Hintergrundfarbe
	captionpos=b,				% Position der Listingunterschrift
	float
}

% define colors for code highlighting
\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\definecolor{darkgray}{rgb}{0.4, 0.4, 0.4}
\definecolor{editorGray}{rgb}{0.95, 0.95, 0.95}
\definecolor{editorOcher}{rgb}{1, 0.5, 0} % #FF7F00 -> rgb(239, 169, 0)
\definecolor{editorGreen}{rgb}{0, 0.5, 0} % #007C00 -> rgb(0, 124, 0)
\definecolor{orange}{rgb}{1,0.45,0.13}		
\definecolor{olive}{rgb}{0.17,0.59,0.20}
\definecolor{brown}{rgb}{0.69,0.31,0.31}
\definecolor{purple}{rgb}{0.38,0.18,0.81}
\definecolor{lightblue}{rgb}{0.1,0.57,0.7}
\definecolor{lightred}{rgb}{1,0.4,0.5}
\colorlet{numb}{magenta!60!black}
\newcommand\YAMLcolonstyle{\color{red}\mdseries}
\newcommand\YAMLkeystyle{\color{black}\bfseries}
\newcommand\YAMLvaluestyle{\color{blue}\mdseries}

\lstdefinelanguage{json}{
	basicstyle=\footnotesize\selectfont\ttfamily,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{white},
	literate=
	*{:}{{{\color{punct}{:}}}}{1}
	{,}{{{\color{punct}{,}}}}{1}
	{\{}{{{\color{delim}{\{}}}}{1}
	{\}}{{{\color{delim}{\}}}}}{1}
	{[}{{{\color{delim}{[}}}}{1}
	{]}{{{\color{delim}{]}}}}{1},
}

\lstdefinelanguage{yaml}{
	keywords={true,false,null,y,n},
	keywordstyle=\color{darkgray}\bfseries,
	basicstyle=\footnotesize\selectfont\ttfamily,    
	showstringspaces=false,
	breaklines=true,
	frame=lines,
	sensitive=false,
	comment=[l]{\#},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	moredelim=[l][\color{orange}]{\&},
	moredelim=[l][\color{magenta}]{*},
	moredelim=**[il][\YAMLcolonstyle{:}\YAMLvaluestyle]{:},   % switch to value style at :
	morestring=[b]',
	morestring=[b]",
	literate =    {---}{{\ProcessThreeDashes}}3
	{>}{{\textcolor{red}\textgreater}}1     
	{|}{{\textcolor{red}\textbar}}1 
	{\ -\ }{{\mdseries\ -\ }}3,
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Ein paar Hilfskommandos, die nützlich sein können %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\code}[1]{\textsf{#1}}	% Code in Text
\newcommand{\pkg}[1]{\textsf{#1}}	% Paketnamen
\newcommand{\class}[1]{\textsf{#1}} 	% Klassennamen
\newcommand{\idx}[1]{_\text{#1}} 	% schreibt in Formeln einen nicht kursiven Index

% Einbindung der Biblatex-Datei
\addbibresource{literatur.bib}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Einstellungen für das Dokument %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Der Titel wird hier eingetragen
\title{Trash Bash}

% Der/die Verfasser wird hier angegeben
\author{Kevin Rüter, Wilko Müller}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Hier beginnt das eigentliche Dokument %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
	
	
	%%%%%%%%%%%%%%%%%%
	%%% Titelblatt %%%
	%%%%%%%%%%%%%%%%%%
	\begin{titlepage}
		\begin{center}
			\vspace*{1.5cm}
			\begin{Large}
				\textbf{Universit\"at Osnabr\"uck}
			\end{Large}
			
			\noindent\hrulefill
			\\[3.5cm]
			BERICHT \\[1cm]
			zum Seminar \\[1cm]
			\textbf{Standortbasierte Dienste} \\[1.5cm]    % Seminartitel eintragen 
			im Wintersemester 2019/2020 \\[1.5cm]   % Semester / Datum eintragen
			Thema: \\[0.5cm]
			\textbf{Trash Bash} \\[2cm]        % Titel des eigenen Seminarthemas eintragen
			Erstellt am \today
		\end{center}
		\vfill
		\begin{flushleft}
			Vorgelegt von: 
			\hfill \parbox{60mm}{Kevin Rüter} \\  % Eigene Daten einsetzen
			\hfill \parbox{60mm}{Wilko Müller}
		\end{flushleft}
	\end{titlepage}
	%%% end title page
	
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Inhaltsverzeichnis mit römischen Seitenzahlen %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\newpage
	\pagenumbering{roman}
	\tableofcontents 
	
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Start des Dokumenteninhalts mit arabischen Seitenzahlen %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\newpage
	\pagenumbering{arabic}
	
	\maketitle
	
	\begin{abstract}
		\noindent Im Folgenden wird die Funktionsweise der App „TrashBash“ beschrieben. 
			Sie ist im Rahmen der Veranstaltung „Standortbasierte Dienste“ an der Universität Osnabrück entstanden.
	\end{abstract}
	
	\section{Komponenten}
	Die folgenden Komponenten wurden zur Erstellung der App "TrashBash" genutzt:
	\begin {itemize}
	\item \textbf{Server/Backend}
		\begin {itemize}
			\item \textbf{Express.js:} Stellt die benötigten HTTP-Server Funktionen bereit, für die Schnittstelle zwischen App und Datenbank. Zudem wird, um die Bilder hochzuladen, die \textit{fileupload}-Funktion genutzt.
			\item \textbf{Crypto von Node.js:} Wird benötigt, um den md5-Hashwert für die Bilder zu berechnen.
			\item \textbf{Postgres:} Stellt die Verbindung vom Server-Skript zur Datenbank her.
		\end {itemize}
	\item \textbf{App}
		\begin {itemize}
		\item \textbf{Angular:} Dient als Hauptkomponente zur Strukturierung der App. Vereinfacht beispielsweise den Umgang mit Webinhalten durch Services.
		\item \textbf{Leaflet:} Die Müllmeldekarte wird durch Leaflet eingestellt. Mit Leaflet lassen sich Karten in Webseiten und Apps einbinden und zudem mit Markern und Popups erweitern.
		\item \textbf{Ionic:} Fügt einige Userinterface-Komponenten zu Angular hinzu, die sich durch gutes Design in Android und iOS Apps auszeichnen.
		\end {itemize}
	\end {itemize}

	\subsection{Frontend / App}
	\subsubsection{Leaflet Karte}
	\begin {itemize}
		\item Die Initialisierung der Leaflet Karte wird von der initializeMap-Methode der Angular Map Page durchgeführt. Als Kartendatenprovider kann zwischen \href{https://www.openstreetmap.org}{Open Street Maps} und \href{http://voyager.basemaps.cartocdn.com}				{Voyager} entschieden werden. Die Auswahl kann über die \textit{leaflet-control-layers-expanded} Schaltfläche in der oberen linken Ecke getroffen werden.
		\item Ebenfalls wird in der \textit{initializeMap}-Methode der Standort des App-Nutzers ermittelt. Dazu benutzen wir die Klasse Geolocation aus dem Ionic Native Framework. Zunächst wird die momentane Position in Form von Längen- und Breitengrad durch 					\textit{getCurrentPosition} abgerufen. Da diese Methode asynchron abläuft, muss die komplette \textit{initializeMap}-Methode als \textit{async} definiert werden und mit dem \textit{await} Statement vor dem Aufruf auf die Erfüllung der zurückgegebenen 				\textit{Promise} gewartet werden. Die erhaltenen Daten werden daraufhin einem Standortmarker übergeben.
			Damit die Position des Users stets aktuell bleibt, setzen wir den \textit{UserLocationObserver} aus Ionic Native ein und lassen den Standortmarker auf etwaige Standortveränderungen horchen. So wird der Marker bei einem Standortwechsel verschoben.
		\item Die gemeldeten illegalen Müllablagerungen werden mit einem Leaflet Marker an den jeweiligen Koordinaten dargestellt. Im Abschnitt \hyperref[sec:Filter] {Filter} wird genauer auf das Abrufen der Daten eingegangen.

	\end {itemize}
	\subsubsection{Meldung von Müllablagerungen}
	\begin {itemize}
		\item Die Meldung einer illegalen Müllablagerung wird über den grünen Knopf mit dem Plus in der unteren rechten Ecke gestartet. Daraufhin öffnet sich ein \textit{Angular Modal} Dialog-Fenster, in welchem die Daten zur Müllablagerung vom Nutzer eingetragen 					werden können. Es wird ein \textit{Modal} benutzt, da man es über die Leaflet-Karte legen kann und somit diese im Hintergrund, bei der Eingabe der Mülldetails, visualisiert bleibt. Zudem sorgt die \textit{Ionic}-Funktion \textit{backdrop} für den grauen 					Schleier über der Karte im Hintergrund.
		\item Die Eingabe des Nutzernamens wird über ein \textit{Ionic input} realisiert. Dieser wird in der HTML-Template-Datei zum Müllmelde-Modal \textit{„add.page.html“} definiert. In demselben Template wird auch eine \textit{Ionic-list} angelegt, bestehend aus jeweils 				einem \textit{label} und einer \textit{checkbox}. Die Liste wird mit den vier verschiedenen Kategorien von Müllablagerungen bestückt. Im \textit{label} wird der Name angezeigt und die \textit{checkbox} markiert ob der jeweilige Müll-Typ vorhanden ist.
			Damit auch Bilder der Müllablagerung mitgesendet werden können benötigen wir aus\textit{ Ionic Native} die \textit{Camera}-Klasse. Diese beruht auf dem \textit{Cordova-Camera-Plugin} um an die Hardware Funktionen der Smartphone-Kamera und die 				gespeicherten Fotos zu gelangen. Da das Hinzufügen von Bildern optional ist, wird vor dem Absenden der Meldung dem Nutzer ein \textit{Ionic action-sheet} präsentiert. Dieses \textit{Ionic} Gestaltungselement ist dazu gedacht eine Auswahl von Optionen zu 				präsentieren. Es gibt zwei \textit{action-sheets} im Müllmeldeprozess. Im ersten kann ausgewählt werden, ob ein Bild angefügt werden soll. Beantwortet man dies mit „Nein“ wird die Meldung direkt an die Datenbank gesendet. Wird „Ja“ gewählt kommt ein 				zweites \textit{action-sheet} in welchem man sich entscheiden kann, ob man ein neues Bild mit der Kamera aufnehmen möchte oder eins aus der Fotogalerie hochladen möchte. Die beiden Funktionen werden plattformunabhängig von \textit{Cordova} über 				\textit{Ionic} bereitgestellt. Die von uns erstellte Funktion \textit{getImage(sourceType: number)} speichert das Bild aus der jeweiligen Quelle im JPEG-Format ab und löst \textit{sendReport} aus. Die Meldung ist dann abgeschlossen und man gelangt wieder 				zurück auf die Karte.

	\end{itemize}

	\subsubsection{Filter}
	\begin {itemize}
		\item Über den \textit{Ionic Button} \textbf{Filter} mittig am unteren Rand platziert, lässt sich einstellen welche Meldungen von Müllablagerungen auf der Karte angezeigt werden sollen. Klickt man auf diesen Button öffnet sich, wie auch bei der Müllmeldung ein 					\textit{Ionic Modal}. In diesem lässt sich nach den folgenden Paramatern sortieren: Username, Zeitraum, Müllart und einem Umgebungsradius. Um einen Filter darzustellen, haben wir eine \textit{Typescript}-Klasse Filter angelegt, die die genannten Parameter 				abspeichert und mit getter- und setter-Methoden manipulierbar macht.
			Möchte der Nutzer beispielsweise nur Meldungen von der Nutzerin “Martha Musterfrau” angezeigt bekommen, die in einem Umkreis von 50 km um seinen aktuellen Standort gemeldet wurden, müssen zwei Einstellungen im Filter \textit{Modal} getroffen werden. 				Erstens wird der Nutzername in den \textit{Ionic} Input „Username“ eingetippt und zweitens der \textit{Ionic} Slider auf den Wert 50, für den Radius in Kilometern, eingestellt.
			Da der Filter durch den \textit{Angular-Service map.service} bereitgestellt wird, können die Änderungen über die \textit{setFilters()}-Funktion direkt abgespeichert werden. Dann wird die \textit{applyFilters()}-Funktion mit \textit{true} als Übergabewert 				aufgerufen und der im \textit{mapService} hinterlegte Filter wird durch Serverabfragen angewendet, sodass nur noch die gewünschten Marker auf der Leaflet-Karte angezeigt werden.
	\end {itemize}
	
	\subsection{Backend}
	\begin {itemize}
		\item In diesem Abschnitt wird erklärt wie der Server als Schnittstelle zwischen App und Datenbank fungiert. Die zwei Hauptfunktionen des Servers sind unter dem Endpoint \textit{/trash} mit HTTP-Get und POST erreichbar.
		\item Mit der GET-Methode werden die Anfragen der App nach Müllablagerungen bedient. Dort wird zuerst überprüft, ob die drei von der App zu sendeten Werte Latitude, Longitude und Radius wirklich gesendet wurden. Ist dies nicht der Fall wird der HTTP-Fehler 				400 (Bad Request) zurückgegeben. Danach wird geschaut, ob ein Start- und Enddatum vorhanden ist. Wenn keine Daten in der Filterfunktion der App angegeben wurden, werden die letzten 14 Tage als Anzeigezeitraum gewählt.
		\item Die zur Datenbankabfrage notwendigen Daten sind dann bereit, sodass folgendes Statement an die Datenbank geschickt werden kann:\textit{ “SELECT * FROM trash WHERE time BETWEEN startDate AND endDate ORDER BY id ASC”}. So bekommt man alle 				Müllablagerungsmeldungen zwischen Start- und Enddatum nach Meldezeitpunkt sortiert, da die \textit {id} als Primärschlüssel bei jeder Meldung hochgezählt wird.
			Die so erhaltenen Zeilen aus der Datenbank müssen noch auf den im Filter gewählten Radius ausgedünnt werden. Für die Berechnung wurde die Funktion \textit{getTrashDistance(center, marker)} geschrieben, um die Distanz auf der Erdkugel zu berechnen. 				Dabei enthält \textit{center} die Koordinaten des Nutzers, und \textit{marker} die der Müllmeldung. Die Koordinaten, der in dem Radius liegenden Meldungen, werden als Punkte im GeoJSON Format zurückgegeben. So können die Marker in der App an den 				passenden Punkten angezeigt werden.
		\item Die dritte Funktion des Servers ist es die vom Nutzer hochzuladenden Bilder anzunehmen. Zuerst wird überprüft, ob im empfangenen Body sich ein \textit{files}-Objekt befindet. Ist dies nicht der Fall wird der Statuscode 400 für Bad Request 							zurückgegeben. Das Foto wird mit dem eigenen md5-Hashwert als Dateinamen abgespeichert und an die App wird zusammen, mit Statuscode 200 der Dateipfad auf dem Server zurückgeschickt. Ansonsten kommt HTTP-Code 500 Internal Server Error, falls die 				Datei nicht abgespeichert werden kann.
	\end {itemize}
	                     
	\printbibliography
\end{document}